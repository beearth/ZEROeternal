[
  {
    "projectId": "817b64d2-715a-4e0e-9a29-990c26d07591",
    "testId": "5cd196d9-4364-4500-aeed-650112c411cb",
    "userId": "247824c8-3001-70d3-dd8f-570ed881751f",
    "title": "TC001-Successful Google Login via Firebase Authentication",
    "description": "Verify that a user can log in successfully using Firebase Authentication with a valid Google account.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Authentication Successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: User login with Firebase Authentication using a valid Google account did not succeed as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The login page cannot be loaded due to a critical missing module error in the app environment. This prevents testing the Firebase Authentication with Google login. The issue has been reported. Task cannot proceed further until the app is fixed.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] [vite] failed to connect to websocket.\nyour current setup:\n  (browser) localhost:3000/ <--[HTTP]--> localhost:3000/ (server)\n  (browser) localhost:3000/ <--[WebSocket (failing)]--> localhost:3000/ (server)\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr . (at http://localhost:3000/@vite/client:510:16)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/247824c8-3001-70d3-dd8f-570ed881751f/1765333430167943//tmp/test_task/result.webm",
    "created": "2025-12-10T02:23:20.963Z",
    "modified": "2025-12-10T02:23:50.288Z"
  },
  {
    "projectId": "817b64d2-715a-4e0e-9a29-990c26d07591",
    "testId": "023710f5-611a-42ed-a514-462f160421f1",
    "userId": "247824c8-3001-70d3-dd8f-570ed881751f",
    "title": "TC002-Google Login Failure with Invalid Credentials",
    "description": "Verify the system handles failed login attempts appropriately when Google authentication fails or is cancelled.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Login Successful! Welcome back').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test failed: The login with Google authentication did not succeed as expected. The user should remain on the login page and see an error message indicating the failure of Google authentication.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task to verify the system's handling of failed Google login attempts could not be completed because the login page failed to load due to a critical missing module error ('dep-CvfTChi5.js') in the Vite build system. This error prevented any interaction with the login UI or Google login button, blocking the entire login flow. The test steps to simulate Google authentication failure or cancellation and verify error handling could not be performed. The issue must be resolved by fixing the missing module or build configuration before the test can be executed successfully.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] [vite] failed to connect to websocket.\nyour current setup:\n  (browser) localhost:3000/ <--[HTTP]--> localhost:3000/ (server)\n  (browser) localhost:3000/ <--[WebSocket (failing)]--> localhost:3000/ (server)\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr . (at http://localhost:3000/@vite/client:510:16)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/247824c8-3001-70d3-dd8f-570ed881751f/1765333488187994//tmp/test_task/result.webm",
    "created": "2025-12-10T02:23:20.970Z",
    "modified": "2025-12-10T02:24:48.307Z"
  },
  {
    "projectId": "817b64d2-715a-4e0e-9a29-990c26d07591",
    "testId": "897a28e0-e7bc-414b-99cc-85a8ad2ccf76",
    "userId": "247824c8-3001-70d3-dd8f-570ed881751f",
    "title": "TC003-Successful Onboarding Modal Language and Content Preference Selection",
    "description": "Verify onboarding modal correctly captures user language and content type preferences and stores them.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Onboarding Preferences Saved Successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The onboarding modal did not correctly capture or save user language and content type preferences as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The app failed to load due to a missing module error, preventing access to the onboarding modal. Therefore, it was not possible to verify if the onboarding modal correctly captures user language and content type preferences or stores them. The issue has been reported.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] [vite] failed to connect to websocket.\nyour current setup:\n  (browser) localhost:3000/ <--[HTTP]--> localhost:3000/ (server)\n  (browser) localhost:3000/ <--[WebSocket (failing)]--> localhost:3000/ (server)\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr . (at http://localhost:3000/@vite/client:510:16)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/247824c8-3001-70d3-dd8f-570ed881751f/1765333431916879//tmp/test_task/result.webm",
    "created": "2025-12-10T02:23:20.976Z",
    "modified": "2025-12-10T02:23:52.035Z"
  },
  {
    "projectId": "817b64d2-715a-4e0e-9a29-990c26d07591",
    "testId": "9cc4d4b6-49af-40a8-b9d4-3c5ce97730c1",
    "userId": "247824c8-3001-70d3-dd8f-570ed881751f",
    "title": "TC004-AI Chat Interface Responds with Contextual Gemini API Responses",
    "description": "Verify that the AI chat interface correctly sends user inputs to Gemini API and displays appropriate, contextual AI-generated responses with clickable vocabulary words.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=This is a completely unrelated phrase that does not exist').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The AI chat interface did not send user inputs to Gemini API or did not display appropriate, contextual AI-generated responses with clickable vocabulary words as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The AI chat interface could not be tested because the application fails to load due to a critical missing module error in the vite build system. This prevents login, navigation, input, and response verification. The issue has been reported. Please fix the build error to enable testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] [vite] failed to connect to websocket.\nyour current setup:\n  (browser) localhost:3000/ <--[HTTP]--> localhost:3000/ (server)\n  (browser) localhost:3000/ <--[WebSocket (failing)]--> localhost:3000/ (server)\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr . (at http://localhost:3000/@vite/client:510:16)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/247824c8-3001-70d3-dd8f-570ed881751f/1765333442443969//tmp/test_task/result.webm",
    "created": "2025-12-10T02:23:20.983Z",
    "modified": "2025-12-10T02:24:02.610Z"
  },
  {
    "projectId": "817b64d2-715a-4e0e-9a29-990c26d07591",
    "testId": "3a946403-3446-413b-a5ae-3f2e894634c1",
    "userId": "247824c8-3001-70d3-dd8f-570ed881751f",
    "title": "TC005-WordCard Popup Opens and Displays Correct Details",
    "description": "Verify clicking vocabulary words in AI chat responses opens the WordCard popup showing word details correctly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=ThisWordDoesNotExistInChatResponse').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Clicking vocabulary words in AI chat responses did not open the WordCard popup with the correct word details as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The app failed to load due to a missing module error. Cannot proceed with testing vocabulary word clicks until the issue is resolved.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] [vite] failed to connect to websocket.\nyour current setup:\n  (browser) localhost:3000/ <--[HTTP]--> localhost:3000/ (server)\n  (browser) localhost:3000/ <--[WebSocket (failing)]--> localhost:3000/ (server)\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr . (at http://localhost:3000/@vite/client:510:16)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/247824c8-3001-70d3-dd8f-570ed881751f/1765333423433081//tmp/test_task/result.webm",
    "created": "2025-12-10T02:23:20.988Z",
    "modified": "2025-12-10T02:23:43.554Z"
  },
  {
    "projectId": "817b64d2-715a-4e0e-9a29-990c26d07591",
    "testId": "1a2b1e4b-37f1-4dbe-b942-798834cdd4a4",
    "userId": "247824c8-3001-70d3-dd8f-570ed881751f",
    "title": "TC006-Radial Menu Updates Word Status and Important Flag Correctly",
    "description": "Verify the radial menu in WordCard component updates the selected word's state (Red, Yellow, Green, Important) correctly and persists changes.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Word status updated to Blue').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The radial menu in WordCard component did not update the selected word's state correctly or changes did not persist as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The WordCard component testing cannot proceed due to a critical module resolution error preventing the app from loading. The issue has been reported. Please fix the environment to enable testing of the radial menu state updates and persistence.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] [vite] failed to connect to websocket.\nyour current setup:\n  (browser) localhost:3000/ <--[HTTP]--> localhost:3000/ (server)\n  (browser) localhost:3000/ <--[WebSocket (failing)]--> localhost:3000/ (server)\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr . (at http://localhost:3000/@vite/client:510:16)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/247824c8-3001-70d3-dd8f-570ed881751f/1765333431637995//tmp/test_task/result.webm",
    "created": "2025-12-10T02:23:20.993Z",
    "modified": "2025-12-10T02:23:51.778Z"
  },
  {
    "projectId": "817b64d2-715a-4e0e-9a29-990c26d07591",
    "testId": "1a337e4a-6cd8-4694-a092-c76c888e8125",
    "userId": "247824c8-3001-70d3-dd8f-570ed881751f",
    "title": "TC007-Pronunciation Audio Plays Correctly from WordCard",
    "description": "Verify the pronunciation audio feature in the WordCard plays the correct audio for the selected word.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Check if there is any way to refresh or navigate to a different page with content or try to find any hidden elements or menus.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Audio Playback Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The pronunciation audio feature in the WordCard did not play the correct audio as expected. Audio playback controls might be missing or non-functional.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The app cannot be tested for the pronunciation audio feature because it fails to load due to a missing module error. This critical issue prevents accessing the WordCard popup and verifying the audio playback functionality. Please fix the module loading error to proceed with testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] [vite] failed to connect to websocket.\nyour current setup:\n  (browser) localhost:3000/ <--[HTTP]--> localhost:3000/ (server)\n  (browser) localhost:3000/ <--[WebSocket (failing)]--> localhost:3000/ (server)\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr . (at http://localhost:3000/@vite/client:510:16)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/247824c8-3001-70d3-dd8f-570ed881751f/1765333435702395//tmp/test_task/result.webm",
    "created": "2025-12-10T02:23:20.999Z",
    "modified": "2025-12-10T02:23:55.868Z"
  },
  {
    "projectId": "817b64d2-715a-4e0e-9a29-990c26d07591",
    "testId": "36255b99-ed8f-4a12-af88-28dfa28f0dab",
    "userId": "247824c8-3001-70d3-dd8f-570ed881751f",
    "title": "TC008-Saving Example Sentences in WordCard",
    "description": "Verify that users can enter and save example sentences related to a vocabulary word and that the sentences persist and appear appropriately.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Example sentence saved successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The example sentence was not saved or did not persist as expected according to the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The app failed to load due to a missing module error. Cannot proceed with the test until the issue is fixed.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] [vite] failed to connect to websocket.\nyour current setup:\n  (browser) localhost:3000/ <--[HTTP]--> localhost:3000/ (server)\n  (browser) localhost:3000/ <--[WebSocket (failing)]--> localhost:3000/ (server)\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr . (at http://localhost:3000/@vite/client:510:16)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/247824c8-3001-70d3-dd8f-570ed881751f/1765333423386998//tmp/test_task/result.webm",
    "created": "2025-12-10T02:23:21.004Z",
    "modified": "2025-12-10T02:23:43.503Z"
  },
  {
    "projectId": "817b64d2-715a-4e0e-9a29-990c26d07591",
    "testId": "c05a06c1-e573-4f28-852d-8ac16a5c1414",
    "userId": "247824c8-3001-70d3-dd8f-570ed881751f",
    "title": "TC009-Vocabulary Stacks Update and Synchronize in Real-Time",
    "description": "Verify that updates to vocabulary word status or added sentences reflect immediately in the vocabulary stacks and sync through Firebase Firestore across multiple devices.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Vocabulary Sync Successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The vocabulary word status updates and added sentences did not reflect immediately in the vocabulary stacks or sync through Firebase Firestore across multiple devices as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The app at localhost:3000 failed to load due to a missing module error related to vite. Cannot proceed with the vocabulary stack update and sync test until the app is fixed and loads correctly.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] [vite] failed to connect to websocket.\nyour current setup:\n  (browser) localhost:3000/ <--[HTTP]--> localhost:3000/ (server)\n  (browser) localhost:3000/ <--[WebSocket (failing)]--> localhost:3000/ (server)\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr . (at http://localhost:3000/@vite/client:510:16)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/247824c8-3001-70d3-dd8f-570ed881751f/1765333423293362//tmp/test_task/result.webm",
    "created": "2025-12-10T02:23:21.010Z",
    "modified": "2025-12-10T02:23:43.435Z"
  },
  {
    "projectId": "817b64d2-715a-4e0e-9a29-990c26d07591",
    "testId": "579e7d4a-4afc-48b7-857b-fcff70f0c546",
    "userId": "247824c8-3001-70d3-dd8f-570ed881751f",
    "title": "TC010-Sidebar Navigation Shows Correct Vocabulary Stacks and Conversation History",
    "description": "Verify the sidebar component accurately displays current vocabulary stacks with real-time word counts and conversation histories.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Vocabulary Stack Overview').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The sidebar component did not accurately display current vocabulary stacks with real-time word counts and conversation histories as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The application failed to load due to a critical missing module error, preventing login and navigation to the main interface. Therefore, I could not verify the sidebar component for vocabulary stacks, word counts, or conversation histories. Task cannot be completed under current conditions.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] [vite] failed to connect to websocket.\nyour current setup:\n  (browser) localhost:3000/ <--[HTTP]--> localhost:3000/ (server)\n  (browser) localhost:3000/ <--[WebSocket (failing)]--> localhost:3000/ (server)\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr . (at http://localhost:3000/@vite/client:510:16)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/247824c8-3001-70d3-dd8f-570ed881751f/1765333433460455//tmp/test_task/result.webm",
    "created": "2025-12-10T02:23:21.016Z",
    "modified": "2025-12-10T02:23:53.573Z"
  },
  {
    "projectId": "817b64d2-715a-4e0e-9a29-990c26d07591",
    "testId": "eed1aae6-dd30-48a8-9640-7a2a1abf02fe",
    "userId": "247824c8-3001-70d3-dd8f-570ed881751f",
    "title": "TC011-Community Post Creation, Editing, and Persistence",
    "description": "Verify that users can create new posts, edit existing ones, and that changes persist and display correctly in the community feed.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Post creation successful!').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test plan execution failed to verify that users can create new posts, edit existing ones, and that changes persist and display correctly in the community feed.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The app failed to load due to a missing module error. Cannot proceed with testing post creation, editing, or verification. Please fix the module resolution error and restart the app.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] [vite] failed to connect to websocket.\nyour current setup:\n  (browser) localhost:3000/ <--[HTTP]--> localhost:3000/ (server)\n  (browser) localhost:3000/ <--[WebSocket (failing)]--> localhost:3000/ (server)\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr . (at http://localhost:3000/@vite/client:510:16)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/247824c8-3001-70d3-dd8f-570ed881751f/1765333422680666//tmp/test_task/result.webm",
    "created": "2025-12-10T02:23:21.021Z",
    "modified": "2025-12-10T02:23:42.797Z"
  },
  {
    "projectId": "817b64d2-715a-4e0e-9a29-990c26d07591",
    "testId": "26c02f58-62bc-4238-a23b-cb35d9043679",
    "userId": "247824c8-3001-70d3-dd8f-570ed881751f",
    "title": "TC012-Community Post Commenting and Liking Functionality",
    "description": "Verify that users can comment on posts, like posts, and that these interactions are reflected correctly and persisted.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Comment submission successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The test plan execution failed to verify that users can comment on posts, like posts, and that these interactions are reflected correctly and persisted.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The test to verify commenting and liking on posts could not be completed due to a critical module loading error on the website. The error prevents loading the community posts and interactive elements needed for the test. Please fix the module loading issue and retry the test.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] [vite] failed to connect to websocket.\nyour current setup:\n  (browser) localhost:3000/ <--[HTTP]--> localhost:3000/ (server)\n  (browser) localhost:3000/ <--[WebSocket (failing)]--> localhost:3000/ (server)\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr . (at http://localhost:3000/@vite/client:510:16)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/247824c8-3001-70d3-dd8f-570ed881751f/1765333430045592//tmp/test_task/result.webm",
    "created": "2025-12-10T02:23:21.028Z",
    "modified": "2025-12-10T02:23:50.195Z"
  },
  {
    "projectId": "817b64d2-715a-4e0e-9a29-990c26d07591",
    "testId": "7d9020cf-dca7-4c98-9f70-8452d128f93e",
    "userId": "247824c8-3001-70d3-dd8f-570ed881751f",
    "title": "TC013-User Profile Editing and Data Persistence",
    "description": "Verify that a user can edit their profile information and that changes persist and reflect correctly across the application.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Profile update successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: User profile information edit did not persist or reflect correctly across the application as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The application cannot be tested for profile editing due to a critical module resolution error preventing it from loading. The issue has been reported. Please fix the error and retry the test.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] [vite] failed to connect to websocket.\nyour current setup:\n  (browser) localhost:3000/ <--[HTTP]--> localhost:3000/ (server)\n  (browser) localhost:3000/ <--[WebSocket (failing)]--> localhost:3000/ (server)\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr . (at http://localhost:3000/@vite/client:510:16)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/247824c8-3001-70d3-dd8f-570ed881751f/1765333428870038//tmp/test_task/result.webm",
    "created": "2025-12-10T02:23:21.034Z",
    "modified": "2025-12-10T02:23:49.000Z"
  },
  {
    "projectId": "817b64d2-715a-4e0e-9a29-990c26d07591",
    "testId": "3bd66729-b082-44a6-b5db-0e2ddb1d2486",
    "userId": "247824c8-3001-70d3-dd8f-570ed881751f",
    "title": "TC014-Real-Time Global Chat Message Send and Receive",
    "description": "Verify that users can send messages in the global chat room and receive messages from others in real-time.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Message delivery confirmed').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Unable to verify real-time message sending and receiving in the global chat room as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The app failed to load due to a missing module error, preventing access to the global chat room. Unable to proceed with the chat message sending and receiving test.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] [vite] failed to connect to websocket.\nyour current setup:\n  (browser) localhost:3000/ <--[HTTP]--> localhost:3000/ (server)\n  (browser) localhost:3000/ <--[WebSocket (failing)]--> localhost:3000/ (server)\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr . (at http://localhost:3000/@vite/client:510:16)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/247824c8-3001-70d3-dd8f-570ed881751f/1765333429418535//tmp/test_task/result.webm",
    "created": "2025-12-10T02:23:21.040Z",
    "modified": "2025-12-10T02:23:49.564Z"
  },
  {
    "projectId": "817b64d2-715a-4e0e-9a29-990c26d07591",
    "testId": "1da48e03-12dd-43a5-a8fe-88e3d5374268",
    "userId": "247824c8-3001-70d3-dd8f-570ed881751f",
    "title": "TC015-1:1 Direct Chat Message Exchange and Synchronization",
    "description": "Verify that direct chat between two users functions correctly with sending, receiving, and real-time synchronization of messages.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Message delivery confirmed').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Direct chat message sending, receiving, and real-time synchronization did not function correctly as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The direct chat functionality could not be tested due to a critical module missing error preventing the app from loading. The issue has been reported. Please fix the environment to enable testing of sending, receiving, and real-time synchronization of messages.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] [vite] failed to connect to websocket.\nyour current setup:\n  (browser) localhost:3000/ <--[HTTP]--> localhost:3000/ (server)\n  (browser) localhost:3000/ <--[WebSocket (failing)]--> localhost:3000/ (server)\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr . (at http://localhost:3000/@vite/client:510:16)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/247824c8-3001-70d3-dd8f-570ed881751f/1765333437032044//tmp/test_task/result.webm",
    "created": "2025-12-10T02:23:21.047Z",
    "modified": "2025-12-10T02:23:57.244Z"
  },
  {
    "projectId": "817b64d2-715a-4e0e-9a29-990c26d07591",
    "testId": "c079b949-e75f-4e19-af74-7337df248059",
    "userId": "247824c8-3001-70d3-dd8f-570ed881751f",
    "title": "TC016-Error Handling for AI Chat Response Failure",
    "description": "Verify that when the Gemini API fails to return a response or returns an error, the AI chat interface handles this gracefully.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Gemini API responded successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test failed: Gemini API failure was not handled gracefully. Expected an error notification or message to be shown to the user, but none was found. The chat interface stability and resend functionality could not be confirmed.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The app failed to load due to a missing module error, so I could not proceed with testing the Gemini API failure handling in the AI chat interface. Please fix the app environment and reload the page to continue testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] [vite] failed to connect to websocket.\nyour current setup:\n  (browser) localhost:3000/ <--[HTTP]--> localhost:3000/ (server)\n  (browser) localhost:3000/ <--[WebSocket (failing)]--> localhost:3000/ (server)\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr . (at http://localhost:3000/@vite/client:510:16)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/247824c8-3001-70d3-dd8f-570ed881751f/1765333430072213//tmp/test_task/result.webm",
    "created": "2025-12-10T02:23:21.058Z",
    "modified": "2025-12-10T02:23:50.230Z"
  },
  {
    "projectId": "817b64d2-715a-4e0e-9a29-990c26d07591",
    "testId": "66cbd95c-9fc8-4bf4-b670-24bdbc6ab830",
    "userId": "247824c8-3001-70d3-dd8f-570ed881751f",
    "title": "TC017-Vocabulary Stack Filter Edge Cases",
    "description": "Verify the vocabulary stack filtering handles edge cases such as empty stacks, large numbers of words, and simultaneous updates from multiple sources.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Vocabulary Stack Loaded Successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The vocabulary stack filtering did not handle edge cases as expected. Empty stacks, large numbers of words, and simultaneous updates from multiple sources were not processed correctly.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The app is not functional due to a critical module loading error. Testing of vocabulary stack filtering cannot proceed until the issue is resolved.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] [vite] failed to connect to websocket.\nyour current setup:\n  (browser) localhost:3000/ <--[HTTP]--> localhost:3000/ (server)\n  (browser) localhost:3000/ <--[WebSocket (failing)]--> localhost:3000/ (server)\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr . (at http://localhost:3000/@vite/client:510:16)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/247824c8-3001-70d3-dd8f-570ed881751f/1765333432464212//tmp/test_task/result.webm",
    "created": "2025-12-10T02:23:21.066Z",
    "modified": "2025-12-10T02:23:52.650Z"
  },
  {
    "projectId": "817b64d2-715a-4e0e-9a29-990c26d07591",
    "testId": "e6a03e1c-2ae0-4398-a300-50a54992859f",
    "userId": "247824c8-3001-70d3-dd8f-570ed881751f",
    "title": "TC018-Logout and Session Termination",
    "description": "Verify that user logout terminates session properly and returns user to the login page.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Welcome Back, signalvoca!').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test failed: User logout did not terminate session properly or redirect to login page as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The application cannot be tested for logout functionality because it fails to load due to a missing module error. The issue has been reported. Please fix the module loading error to enable testing of user logout and session termination.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/' failed: Error during WebSocket handshake: Unexpected response code: 400 (at http://localhost:3000/@vite/client:534:0)\n[ERROR] [vite] failed to connect to websocket.\nyour current setup:\n  (browser) localhost:3000/ <--[HTTP]--> localhost:3000/ (server)\n  (browser) localhost:3000/ <--[WebSocket (failing)]--> localhost:3000/ (server)\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr . (at http://localhost:3000/@vite/client:510:16)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/247824c8-3001-70d3-dd8f-570ed881751f/1765333437264385//tmp/test_task/result.webm",
    "created": "2025-12-10T02:23:21.073Z",
    "modified": "2025-12-10T02:23:57.408Z"
  }
]
